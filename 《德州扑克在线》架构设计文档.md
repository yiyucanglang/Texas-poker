# 《德州扑克在线》架构设计文档 (ADD)

| **文档状态** | **[修订版]** | **版本号** | **v1.2** |
| :--- | :--- | :--- | :--- |
| **关联需求** | 《德州扑克在线》产品需求文档 (PRD) v2.0 |
| **创建日期** | 2025-07-31 | **设计人** | Gemini AI |

---

## 1. 架构概述

本系统旨在为小范围熟人社交圈提供一个实时的在线德州扑克游戏平台。核心挑战在于管理多个游戏房间的实时状态、保证玩家操作的即时响应以及确保游戏的公平与安全。

我们将采用**客户端-服务器 (Client-Server)** 架构模式。后端作为中心权威，处理所有游戏逻辑、数据存储和状态同步；前端则专注于UI展示和用户交互。

通信上，采用 **HTTP/HTTPS + WebSocket** 的混合模式：
* **HTTP/HTTPS (RESTful API):** 用于处理非实时、请求-响应式的操作，如用户注册、登录、个人信息修改、历史战绩查询等。
* **WebSocket:** 用于处理所有实时游戏交互，如加入房间、准备、出牌、下注、同步游戏状态等。这能确保低延迟的双向通信。

---

## 2. 技术选型

| **模块** | **技术/框架** | **选型理由** |
| :--- | :--- | :--- |
| **前端** | **Vue.js 3** / **React** | - **组件化开发**: 便于构建和维护复杂的UI界面（如牌桌、玩家状态、操作按钮等）。<br>- **响应式数据绑定**: 能轻松地将后端推送的游戏状态实时反映到视图上。<br>- **生态成熟**: 拥有大量UI库和工具，可加速开发。 |
| **后端** | **Node.js** + **Express.js** + **Socket.IO** | - **非阻塞I/O**: Node.js的事件驱动模型非常适合处理大量并发的WebSocket连接，是实时应用的绝佳选择。<br>- **Express.js**: 成熟、简洁的Web框架，用于快速搭建RESTful API。<br>- **Socket.IO**: 强大的实时通信库，封装了WebSocket，并提供了自动重连、心跳检测等机制，完美契合**断线重连 (PRD 2.3.7)** 的需求。 |
| **数据库 (持久化)** | **PostgreSQL** | - **关系型数据库**: 用户、房间、历史战绩之间存在清晰的关系，PostgreSQL能提供强大的事务支持和数据一致性。<br>- **JSONB数据类型**: 可以方便地存储房间配置、牌局回顾等半结构化数据。<br>- **稳定可靠**: 业界公认的稳定、功能强大的开源数据库。 |
| **实时状态存储** | **服务器内存 (In-Memory)** | - **简化开发**: 在项目第一阶段，将实时游戏状态（如手牌、底池、玩家筹码等）存储在Node.js服务的内存变量中，可以快速启动开发，降低初期架构复杂性。<br>- **高性能**: 内存读写速度极快，能完全满足实时游戏的需求。<br>- **未来扩展**: 未来当需要支持服务横向扩展或增强数据可靠性时，可平滑迁移至Redis。 |
| **认证机制** | **JWT (JSON Web Tokens)** | - **无状态认证**: 服务器无需存储用户Session，便于水平扩展。<br>- **安全通用**: 可以在HTTP Header和WebSocket连接请求中携带，统一认证方案。 |
| **公平性与洗牌算法** | **Fisher-Yates 算法** + **CSPRNG** | - **公平性保障**: 必须使用Fisher-Yates 算法， 必须使用Node.js 内置的 `crypto.randomInt()` 来生成密码学安全的随机数，作为 Fisher-Yates 算法的输入，以确保发牌的绝对公平和不可预测性。 |

---

## 3. 数据库表设计 (PostgreSQL)

### 3.1 `users` (用户信息表)
存储用户的基本注册信息。
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    avatar_url VARCHAR(255),
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 3.2 `game_sessions` (完整牌局记录表)
记录每一场完整的游戏（从房主开局到房间解散或无人）。
```sql
CREATE TABLE game_sessions (
    id SERIAL PRIMARY KEY,
    room_name VARCHAR(100) NOT NULL,
    room_config JSONB NOT NULL, -- 存储房间创建时的参数，如大小盲、带入额等
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ
);
```

### 3.3 `session_participants` (牌局参与者及战绩表)
记录一场牌局中所有参与者的最终成绩，用于历史战绩查询。
```sql
CREATE TABLE session_participants (
    id SERIAL PRIMARY KEY,
    session_id INTEGER REFERENCES game_sessions(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id),
    total_buy_in INTEGER NOT NULL,
    final_score INTEGER NOT NULL, -- 最终盈亏分数
    player_rank SMALLINT,
    UNIQUE(session_id, user_id)
);
```
**说明**:
* **实时游戏状态存储**: 当前牌局的玩家手牌、公共牌、底池大小、轮到谁行动等高频变化的数据将全部存储在**服务器内存**中，例如一个以房间号为键的全局对象 (`let activeRooms = {}`)。
* 一局游戏（Showdown）结束后，计算盈亏，更新**内存中**的玩家筹码。
* 当一个玩家离开房间或整个房间游戏结束时，才将其最终数据（总买入、最终盈亏）从**内存**计算并写入`session_participants`表。

---

## 4. 需求对应功能设计

| **PRD需求点** | **模块** | **实现方案** |
| :--- | :--- | :--- |
| **2.1.1 注册 / 2.1.2 登录** | 用户账户 | - **POST /api/register**: 接收`username`和`password`，密码加盐哈希后存入`users`表。<br>- **POST /api/login**: 验证用户凭据，成功后生成JWT返回给客户端。 |
| **2.1.3 个人信息** | 用户账户 | - **PUT /api/user/profile**: 客户端携带JWT访问，允许用户更新`avatar_url`等信息。 |
| **2.1.4 历史战绩** | 用户账户 | - **GET /api/user/history**: 根据JWT中的用户ID，联查`session_participants`和`game_sessions`表，返回该用户参与过的所有牌局列表。<br>- **GET /api/session/{id}**: 查询指定牌局ID的`game_sessions`详情和所有`session_participants`记录，格式化后返回。 |
| **2.2.1/2.2.2 创建/加入房间** | 游戏房间 | - **创建 (POST /api/room/create)**: 接收房间参数，生成唯一`房间号`，在**服务器内存**中初始化一个房间状态对象，包含配置和等待中的玩家列表。<br>- **加入 (WebSocket `join_room`事件)**: 客户端发送`房间号`。服务器验证`房间号`有效且未满员，将玩家加入**内存中**的房间状态，并向该房间内所有客户端广播`player_joined`事件。 |
| **2.2.3 房间大厅** | 游戏房间 | - 客户端收到`player_joined`或`player_left`事件后，动态更新大厅UI。<br>- 玩家选座、确认带入分数后，发送WebSocket `sit_down`事件，服务器更新**内存中**的状态并广播。<br>- 房主点击开始游戏，发送`start_game`事件。 |
| **2.3 游戏流程 (核心)** | 游戏流程 | - **服务器驱动的状态机**: 游戏开始后，所有逻辑由服务器的**游戏状态机**驱动。状态机管理回合（Pre-flop, Flop...）、行动顺序、计时器。<br>- **WebSocket通信**: 客户端只发送用户意图（如`action:fold`, `action:raise`）。服务器验证操作合法性（是否轮到他、加注金额是否有效），更新**内存中**的游戏状态，然后向房间内所有客户端广播`game_state_update`事件。<br>- **客户端渲染**: 客户端只负责根据收到的`game_state_update`数据包渲染界面，自身不包含任何游戏核心逻辑，杜绝了客户端作弊。 |
| **2.3.3 超时处理** | 游戏流程 | - 当轮到某玩家行动时，服务器为其启动一个**`setTimeout`**计时器。 <br>- 如果在超时前收到玩家操作，则使用`clearTimeout`取消该计时器。<br>- 如果计时器正常触发，服务器将执行默认操作（过牌/弃牌），并推进游戏状态机。 |
| **2.3.5 分池处理** | 游戏流程 | - 在服务器状态机中精确实现分池算法。当有玩家All-in时，根据所有参与者的下注额和筹码量，计算出主池和1个或多个边池的大小及归属玩家。结算时分别计算每个池的赢家。 |
| **2.3.7 断线重连** | 游戏流程 | - **Socket.IO**原生支持。当玩家断线，服务器保留其在**内存中**的游戏数据和座位。JWT是关键。<br>- 玩家重新打开应用，用本地存储的JWT自动登录，并向服务器发送一个`reconnect_me`的WebSocket事件。<br>- 服务器根据JWT找到该用户的ID，检查**服务器内存**中是否有其所在的活跃房间，若有，则将其新的Socket ID与该房间关联，并立即推送一次完整的当前游戏状态。 |
| **2.4.1 公平性** | 非功能性 | - **服务器端洗牌**: 使用Node.js的`crypto`模块实现Fisher-Yates洗牌算法，在每局开始前在服务器上生成一副洗好的牌，存储在**内存中**的房间状态里。客户端绝对接触不到完整的牌堆。 |
| **2.4.2 安全性** | 非功能性 | - **逻辑在服务端**: 所有游戏逻辑、发牌、下注验证、结算均在服务器完成。客户端无法修改手牌或下注额。<br>- **通信加密**: 生产环境部署时，API和WebSocket均使用TLS/SSL加密(HTTPS/WSS)。<br>- **输入验证**: 对所有来自客户端的输入（API和WebSocket消息）进行严格的格式和逻辑验证。 |

---

## 5. 可执行分步任务及验收标准

### **第一阶段：项目基础与用户核心功能 (Sprint 1)**
* **任务**:
    1.  初始化前后端项目结构（Vue.js, Node.js）。
    2.  搭建Express服务器，配置PostgreSQL连接。
    3.  设计并创建`users`数据库表。
    4.  实现用户注册API (`/api/register`)。
    5.  实现用户登录API (`/api/login`)，返回JWT。
    6.  实现一个需要JWT认证的个人信息查询API (`/api/user/profile`)。
    7.  前端完成注册、登录页面的开发，并能成功调用API，将JWT存入本地存储。
* **验收标准**:
    * **场景: 成功注册**
        * **鉴于** 一个新用户在注册页面。
        * **当** 他输入一个唯一的用户名和有效的密码并提交表单时。
        * **那么** 他的账户应该被成功创建，并被重定向到登录页面。
    * **场景: 成功登录**
        * **鉴于** 一个已注册的用户在登录页面。
        * **当** 他输入正确的用户名和密码并提交表单时。
        * **那么** 他应该成功登录并从服务器获取到一个JWT令牌。
    * **场景: 凭据错误登录失败**
        * **鉴于** 一个已注册的用户在登录页面。
        * **当** 他输入了错误的密码时。
        * **那么** 他应该看到一个错误提示信息，并且仍然停留在登录页面。
    * **场景: 访问受保护的个人信息**
        * **鉴于** 一个用户已经登录。
        * **当** 他访问个人中心页面时。
        * **那么** 他的个人信息应该被正确地显示出来。
    * **场景: 未登录用户访问受保护页面**
        * **鉴于** 一个用户未登录。
        * **当** 他尝试直接访问个人中心页面时。
        * **那么** 他应该被自动重定向到登录页面。

### **第二阶段：房间创建与大厅功能 (Sprint 2)**
* **任务**:
    1.  设计并创建`game_sessions`和`session_participants`表。
    2.  实现房间创建API (`/api/room/create`)，能在**服务器内存**中生成房间数据结构。
    3.  配置Socket.IO，实现基础的WebSocket连接和JWT认证。
    4.  实现`join_room`逻辑，允许玩家通过房间号加入。
    5.  实现大厅内的玩家加入、离开、选座、确认带入金额的实时同步。
    6.  实现房主开始游戏的`start_game`指令。
* **验收标准**:
    * **场景: 成功创建房间**
        * **鉴于** 一个已登录的用户在“创建房间”页面。
        * **当** 他填写了所有有效的房间参数并点击“创建”按钮时。
        * **那么** 系统应该成功创建一个新房间，并返回一个全局唯一的房间号。
    * **场景: 玩家成功加入房间**
        * **鉴于** 一个有效的游戏房间已经存在。
        * **当** 另一个已登录的用户输入正确的房间号并点击“加入”时。
        * **那么** 他应该成功进入该房间的大厅，并且大厅内所有其他玩家能实时看到新玩家的加入。
    * **场景: 玩家成功入座**
        * **鉴于** 一个玩家在房间大厅中。
        * **当** 他点击一个空座位并确认带入的筹码数量时。
        * **那么** 他应该成功坐到该座位上，并且所有玩家的界面上都会同步更新这个座位的状态。
    * **场景: 房主启动游戏**
        * **鉴于** 房主在房间大厅中，并且至少有两名玩家已经入座。
        * **当** 房主点击“开始游戏”按钮时。
        * **那么** 游戏应该成功开始，并进入第一手牌的流程。

### **第三阶段：核心游戏流程实现 (Sprint 3)**
* **任务**:
    1.  在服务器端实现完整的德州扑克游戏状态机（发牌、盲注、下注轮次、回合切换）。
    2.  实现服务器端洗牌逻辑（CSPRNG）。
    3.  实现玩家操作（弃牌、跟注、加注等）的WebSocket事件和服务器验证逻辑。
    4.  实现`game_state_update`广播，向客户端同步游戏状态。
    5.  前端开发游戏主界面，能根据`game_state_update`数据动态渲染牌桌、手牌、公共牌、底池、玩家筹码和行动按钮。
* **验收标准**:
    * **场景: 游戏正常开局**
        * **鉴于** 房主已经启动了游戏。
        * **当** 第一手牌开始时。
        * **那么** 庄家按钮（Dealer Button）和大小盲注位置应该被正确分配，并且每位玩家都会收到两张只有自己可见的底牌。
    * **场景: 玩家轮到行动**
        * **鉴于** 牌局正在进行中，轮到某位玩家行动。
        * **当** 该玩家查看自己的游戏界面时。
        * **那么** 他的玩家区域应该高亮显示，并且相应的操作按钮（如“弃牌”、“跟注”、“加注”）应该被激活可用。
    * **场景: 玩家执行操作**
        * **鉴于** 轮到某位玩家行动。
        * **当** 他点击一个合法的操作按钮（例如“跟注”）时。
        * **那么** 他的操作应该被服务器处理，并且游戏状态（如底池大小、他的筹码量）的变更会实时同步给房间内的所有玩家。
    * **场景: 正常发出公共牌**
        * **鉴于** 一轮下注已经结束。
        * **当** 游戏进入下一阶段时。
        * **那么** 正确的公共牌（翻牌、转牌或河牌）应该被发出并显示在牌桌中央。

### **第四阶段：结算、特殊逻辑与历史记录 (Sprint 4)**
* **任务**:
    1.  实现摊牌比大小的逻辑和胜者判定。
    2.  实现复杂的**分池 (Side Pot)** 计算逻辑。
    3.  实现牌局结算，将底池分配给赢家，并开启新的一局。
    4.  实现玩家离开房间时，结算其最终成绩并写入`game_sessions`和`session_participants`表。
    5.  实现行动超时自动弃牌/过牌的逻辑。
    6.  实现断线重连功能。
    7.  实现历史战绩查询的后端API和前端页面。
* **验收标准**:
    * **场景: 正确处理分池**
        * **鉴于** 一手牌中至少有一位玩家All-in，且其筹码少于其他活跃玩家。
        * **当** 这手牌进入结算阶段时。
        * **那么** 系统必须能正确计算并分配主池和所有边池给各自的赢家。
    * **场景: 行动超时自动处理**
        * **鉴于** 轮到某玩家行动，且之前有玩家下注。
        * **当** 该玩家的行动倒计时结束时。
        * **那么** 系统应该自动为该玩家执行“弃牌”操作。
    * **场景: 成功断线重连**
        * **鉴于** 一位玩家在游戏中断开连接。
        * **当** 他在允许的时间内重新打开应用并登录时。
        * **那么** 他应该能自动返回到之前的牌桌座位上，并保留他断线前的筹码和状态。
    * **场景: 查看历史战绩**
        * **鉴于** 一位玩家已经完成了一场完整的游戏。
        * **当** 他访问个人中心的“历史战绩”页面时。
        * **那么** 他应该能看到这场游戏的记录，点击后可以查看到包含所有玩家排名、总买入和最终盈亏的详细信息。

---

## 6. 整体验收标准

当所有开发阶段完成后，项目应满足以下整体验收标准，以确认为成功交付：

1.  **完整用户流程**: 一个新用户可以完成 **注册 -> 登录 -> 创建房间 -> 分享房间号给朋友 -> 朋友加入房间 -> 房主开始游戏 -> 进行多手完整的牌局（包括下注、All-in、分池等情况） -> 玩家中途离开或游戏自然结束 -> 在个人中心查看该场牌局的详细历史战绩** 的完整闭环，流程顺畅无阻。
2.  **功能完备性**: PRD v2.0中定义的所有功能需求均已实现，并符合描述。
3.  **实时性与稳定性**: 在模拟的网络延迟和抖动环境下，游戏状态同步依然及时，无明显卡顿。多名玩家同时操作，服务器响应正确。长时间运行后，系统资源（内存、CPU）占用稳定，无泄漏。
4.  **公平与安全性**: 无法通过任何前端手段（如查看JS变量、修改网络请求）看到他人的手牌或篡改游戏数据。发牌结果经过多次测试，呈现随机分布特性。
5.  **数据准确性**: 玩家的筹码、买入、盈亏等记分数据在游戏过程中和历史记录中始终保持准确无误。

